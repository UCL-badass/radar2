Model FDM ;

// Modelling Financial Loss

FinancialLoss =AverageFraudValue* NbrCompromisedAccounts*NbrFraudPerAccountBeforeBlocked;

NbrCompromisedAccounts = NbrAccounts * CompromisedAccountRatio;

NbrAccounts = normalCI(0.9 * 10^6, 1.1 * 10^6);

CompromisedAccountRatio = triangular(0, 0.0001, 0.0003 );

AverageFraudValue = normalCI(100, 1000);

NbrFraudPerAccountBeforeBlocked = decision("blocking policy"){
    "block first"          : NbrFraudBeforeDetection;
    "investigage first"    : NbrFraudBeforeDetection + NbrFraudDuringInvestigation;
}

NbrFraudBeforeDetection = decision("processing type"){
	"continuous"    :    1 / ContinuousTrueAlertRate;
	"batch"         :    NbrFraudPerCompromisedAccountPerDay / BatchTrueAlertRate;
}
  
NbrFraudPerCompromisedAccountPerDay = normalCI(1, 20);

NbrFraudDuringInvestigation = NbrFraudPerCompromisedAccountPerDay * InvestigationDelay;

InvestigationDelay = triangular(1/24, 1/3, 1);

ContinuousTrueAlertRate = decision("fraud detection method"){
	"classifier" :  ContinuousAlertThreshold;
	"rule-based" :  deterministic(0.75);
}

ContinuousAlertThreshold = decision("threshold level"){
	"high"   : triangular(0.85, 0.9, 0.95);
	"medium" : triangular(0.75, 0.8, 0.85);
	"low"    : triangular(0.65, 0.7, 0.75);
}

BatchTrueAlertRate = decision("fraud detection method"){
	"classifier" :  BatchAlertThreshold;
	"rule-based" :  deterministic(0.80);
}

BatchAlertThreshold = decision("threshold level"){
	"high"   : triangular(0.9, 0.95, 1);
	"medium" : triangular(0.8, 0.85, 0.9);
	"low"    : triangular(0.7, 0.75, 0.8);
}


// Modelling Investigation Costs

InvestigationCost = NbrAlerts * CostPerAlert; 
    
CostPerAlert = normal(50, 10) ;

NbrAlerts = NbrTrueAlerts + NbrFalseAlerts ;
    
NbrTrueAlerts = NbrFraud * TrueAlertRate;

NbrFalseAlerts = NbrLegitTransactions * TrueNegativeRate ;

TrueAlertRate = decision("processing type"){
    "continuous" : ContinuousTrueAlertRate;
    "batch"      : BatchTrueAlertRate;

}

TrueNegativeRate = decision("processing type"){
    "continuous" : ContinuousTrueNegativeRate;
    "batch"      : BatchTrueNegativeRate;
}	
	
ContinuousTrueNegativeRate = decision("fraud detection method"){
	"classifier" :  ContinuousClassierTrueNegativeRate;
	"rule-based" :  deterministic(0.99);
}

ContinuousClassierTrueNegativeRate = decision("threshold level"){
	"high"   : triangular(0.995, 0.999, 1);
	"medium" : triangular(0.95, 0.99, 0.995);
	"low"   : triangular(0.85, 0.9, 0.95);

}

BatchTrueNegativeRate = decision("fraud detection method"){
	"classifier" :  BatchClassifierTrueNegativeRate;
	"rule-based" :  deterministic(0.995);
}

BatchClassifierTrueNegativeRate = decision("threshold level"){
	"high"   : triangular(0.995, 0.999, 1);
	"medium" : triangular(0.99, 0.995, 0.999);
	"low"    : triangular(0.95, 0.99, 0.995);
}

NbrFraud = NbrAccounts * CompromisedAccountRatio * NbrFraudPerCompromisedAccountPerDay;

NbrLegitTransactions = NbrAccounts  * NbrLegitTransactionsPerAccountPerDay;

NbrFraudPerCompromisedAccountPerDay  = triangular(0, 3, 10);

NbrLegitTransactionsPerAccountPerDay = triangular(0, 3, 10);

// Modelling Development Cost

DevelopmentCost = decision("processing type"){
	"continous": normalCI(20*10^3, 50*10^3);
	"batch": deterministic(35*10^3);
}

// Modelling Benefits

BenefitPerDay = BaseLineLoss - (FinancialLoss - InvestigationCost);
	
OneYearBenefit = 365 * BenefitPerDay  - DevelopmentCost  ;
	
BaseLineLoss = deterministic(10^6); // to be replaced by expected financial loss of current system
    
// The decision objectives    

Objective Max ExpectedBenefit =  EV(OneYearBenefit);

Objective Min VaR =  percentile(OneYearBenefit, 1);

 




